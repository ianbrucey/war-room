#!/usr/bin/env python3
"""
Zero Ambiguity Standards Enforcer

Automates the creation and maintenance of coding standards through three workflows:
1. AUDIT - Extract patterns from existing code
2. GENESIS - Define standards from scratch via reference implementations
3. FREEZE - Create standards just-in-time for new components

Usage:
    python scripts/standards.py audit <directory>
    python scripts/standards.py genesis <tech_stack>
    python scripts/standards.py freeze <component_name>

See guides/standards-workflow.md for detailed explanation.
"""

import os
import sys
import subprocess
import glob

# --- CONFIGURATION ---
STANDARDS_DIR = "context-engine/standards"
STANDARDS_FILES = {
    "ui": os.path.join(STANDARDS_DIR, "ui-components.md"),
    "patterns": os.path.join(STANDARDS_DIR, "coding-patterns.md"),
    "genesis": os.path.join(STANDARDS_DIR, "reference-implementations.md")
}


def ensure_standards_dir():
    """Create standards directory if it doesn't exist."""
    os.makedirs(STANDARDS_DIR, exist_ok=True)
    
    # Create empty standards files if they don't exist
    for filepath in STANDARDS_FILES.values():
        if not os.path.exists(filepath):
            with open(filepath, 'w') as f:
                f.write(f"# {os.path.basename(filepath).replace('-', ' ').title()}\n\n")
                f.write("<!-- Auto-generated by standards.py -->\n\n")


def run_llm(agent_name, prompt, context=""):
    """
    Call the LLM CLI tool.
    
    Args:
        agent_name: "auggie" or "gemini"
        prompt: The task instruction
        context: Additional context to prepend
    
    Returns:
        The LLM's output
    """
    full_prompt = f"{context}\n\n{prompt}" if context else prompt
    
    print(f"   ü§ñ Calling {agent_name}...")
    
    try:
        process = subprocess.run(
            [agent_name, "-p", full_prompt],
            capture_output=True,
            text=True,
            timeout=300
        )
        
        if process.returncode != 0:
            print(f"   ‚ö†Ô∏è  {agent_name} returned error: {process.stderr}")
            sys.exit(1)
        
        return process.stdout.strip()
    
    except FileNotFoundError:
        print(f"   ‚ùå CLI tool '{agent_name}' not found in PATH")
        sys.exit(1)
    
    except subprocess.TimeoutExpired:
        print(f"   ‚ùå {agent_name} timed out")
        sys.exit(1)


def audit_directory(target_dir, file_pattern="*"):
    """
    WORKFLOW A: Extract standards from existing code.
    
    Args:
        target_dir: Directory to audit
        file_pattern: Glob pattern for files (e.g., "*.blade.php", "*.py")
    """
    print("=" * 60)
    print("üïµÔ∏è  AUDIT MODE: Extracting Standards from Existing Code")
    print("=" * 60)
    
    if not os.path.exists(target_dir):
        print(f"‚ùå Directory not found: {target_dir}")
        sys.exit(1)
    
    # Find all matching files
    search_pattern = os.path.join(target_dir, "**", file_pattern)
    files = glob.glob(search_pattern, recursive=True)
    
    if not files:
        print(f"‚ùå No files found matching pattern: {file_pattern}")
        sys.exit(1)
    
    print(f"\nüìÅ Found {len(files)} files to audit\n")
    
    extracted_standards = []
    
    for filepath in files:
        print(f"   Analyzing: {filepath}")
        
        with open(filepath, 'r') as f:
            file_content = f.read()
        
        prompt = f"""
Analyze this code file and extract reusable patterns.

File: {filepath}

TASK:
1. Identify any reusable components, functions, or patterns
2. Document the public API (props, parameters, return types)
3. Write a concise documentation entry in markdown format

Output ONLY the documentation entry, no explanations.
"""
        
        context = f"```\n{file_content}\n```"
        
        result = run_llm("auggie", prompt, context)
        extracted_standards.append(f"\n## {os.path.basename(filepath)}\n\n{result}\n")
    
    # Append to appropriate standards file
    output_file = STANDARDS_FILES["ui"] if "component" in target_dir.lower() else STANDARDS_FILES["patterns"]
    
    with open(output_file, 'a') as f:
        f.write("\n---\n")
        f.write(f"<!-- Extracted from {target_dir} -->\n")
        f.write("".join(extracted_standards))
    
    print(f"\n‚úÖ Standards extracted and saved to: {output_file}")


def run_genesis(tech_stack):
    """
    WORKFLOW B: Define standards from scratch via reference implementation.
    
    Args:
        tech_stack: Description of tech stack (e.g., "Laravel, Livewire, Tailwind")
    """
    print("=" * 60)
    print("‚ú® GENESIS MODE: Creating Standards from Reference Implementation")
    print("=" * 60)
    
    print(f"\nTech Stack: {tech_stack}\n")
    
    # Step 1: Generate Golden Sample
    print("Step 1: Generating reference implementation...")
    
    prompt = f"""
Generate a "Golden Sample" implementation using this tech stack: {tech_stack}

Create TWO examples:
1. A sample UI component (e.g., a Button or Card)
2. A sample backend pattern (e.g., a Controller method or Service class)

These should demonstrate:
- Error handling
- Type safety
- State management
- Naming conventions
- Code organization

Output the code examples with clear labels.
"""
    
    golden_sample = run_llm("auggie", prompt)
    
    print("\n" + "=" * 60)
    print("REFERENCE IMPLEMENTATION:")
    print("=" * 60)
    print(golden_sample)
    print("=" * 60)
    
    # Step 2: Get user approval
    approval = input("\n‚úã Review the above. Approve? (yes/no): ").strip().lower()
    
    if approval != "yes":
        print("‚ùå Genesis cancelled. Refine your tech stack description and try again.")
        sys.exit(0)
    
    # Step 3: Extract patterns from approved sample
    print("\nStep 2: Extracting patterns from approved sample...")
    
    extract_prompt = """
Analyze the approved reference implementation above.

Extract the coding patterns into a set of rules for future development.

Format as a markdown document with sections:
- Component Structure
- Naming Conventions
- Error Handling
- Type Safety
- State Management

Output ONLY the markdown rules document.
"""
    
    patterns = run_llm("auggie", extract_prompt, f"APPROVED SAMPLE:\n\n{golden_sample}")
    
    # Save both the sample and the extracted patterns
    with open(STANDARDS_FILES["genesis"], 'w') as f:
        f.write("# Reference Implementations\n\n")
        f.write("<!-- Generated via Genesis Protocol -->\n\n")
        f.write(golden_sample)
    
    with open(STANDARDS_FILES["patterns"], 'w') as f:
        f.write("# Coding Patterns\n\n")
        f.write("<!-- Extracted from Reference Implementation -->\n\n")
        f.write(patterns)
    
    print(f"\n‚úÖ Reference saved to: {STANDARDS_FILES['genesis']}")
    print(f"‚úÖ Patterns saved to: {STANDARDS_FILES['patterns']}")


def flag_and_freeze(component_name):
    """
    WORKFLOW C: Create a new component and freeze it as a standard.
    
    Args:
        component_name: Name of the component to create (e.g., "DatePicker", "Modal")
    """
    print("=" * 60)
    print(f"‚ùÑÔ∏è  FREEZE MODE: Creating Standard for '{component_name}'")
    print("=" * 60)
    
    # Load existing standards for context
    existing_ui = ""
    if os.path.exists(STANDARDS_FILES["ui"]):
        with open(STANDARDS_FILES["ui"], 'r') as f:
            existing_ui = f.read()
    
    existing_patterns = ""
    if os.path.exists(STANDARDS_FILES["patterns"]):
        with open(STANDARDS_FILES["patterns"], 'r') as f:
            existing_patterns = f.read()
    
    context = f"""
EXISTING UI STANDARDS:
{existing_ui}

EXISTING CODING PATTERNS:
{existing_patterns}
"""
    
    prompt = f"""
Design a new component: {component_name}

REQUIREMENTS:
1. Match the style and patterns of existing components
2. Output TWO things:
   a) The actual code implementation
   b) A documentation entry for ui-components.md

Format:
## CODE
[code here]

## DOCUMENTATION
[markdown documentation entry]
"""
    
    result = run_llm("auggie", prompt, context)
    
    # Parse the result
    if "## CODE" in result and "## DOCUMENTATION" in result:
        code_section = result.split("## CODE")[1].split("## DOCUMENTATION")[0].strip()
        docs_section = result.split("## DOCUMENTATION")[1].strip()
        
        print("\n" + "=" * 60)
        print("GENERATED CODE:")
        print("=" * 60)
        print(code_section)
        print("\n" + "=" * 60)
        print("DOCUMENTATION:")
        print("=" * 60)
        print(docs_section)
        print("=" * 60)
        
        # Ask where to save the code
        save_path = input(f"\nüíæ Save code to (or 'skip'): ").strip()
        
        if save_path and save_path != 'skip':
            os.makedirs(os.path.dirname(save_path), exist_ok=True)
            with open(save_path, 'w') as f:
                f.write(code_section)
            print(f"‚úÖ Code saved to: {save_path}")
        
        # Append documentation
        with open(STANDARDS_FILES["ui"], 'a') as f:
            f.write(f"\n---\n\n## {component_name}\n\n{docs_section}\n")
        
        print(f"‚úÖ Documentation added to: {STANDARDS_FILES['ui']}")
    else:
        print("‚ö†Ô∏è  Could not parse output. Saving raw result...")
        with open(STANDARDS_FILES["ui"], 'a') as f:
            f.write(f"\n---\n\n## {component_name}\n\n{result}\n")


def main():
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python scripts/standards.py audit <directory> [file_pattern]")
        print("  python scripts/standards.py genesis <tech_stack>")
        print("  python scripts/standards.py freeze <component_name>")
        sys.exit(1)
    
    ensure_standards_dir()
    
    mode = sys.argv[1].lower()
    
    if mode == "audit":
        if len(sys.argv) < 3:
            print("‚ùå Missing argument: directory path")
            sys.exit(1)
        target_dir = sys.argv[2]
        file_pattern = sys.argv[3] if len(sys.argv) > 3 else "*"
        audit_directory(target_dir, file_pattern)
    
    elif mode == "genesis":
        if len(sys.argv) < 3:
            print("‚ùå Missing argument: tech stack description")
            sys.exit(1)
        tech_stack = " ".join(sys.argv[2:])
        run_genesis(tech_stack)
    
    elif mode == "freeze":
        if len(sys.argv) < 3:
            print("‚ùå Missing argument: component name")
            sys.exit(1)
        component_name = " ".join(sys.argv[2:])
        flag_and_freeze(component_name)
    
    else:
        print(f"‚ùå Unknown mode: {mode}")
        print("Valid modes: audit, genesis, freeze")
        sys.exit(1)


if __name__ == "__main__":
    main()

